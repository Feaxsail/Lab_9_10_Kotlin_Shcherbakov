Лабораторная работа №9-10: Продвинутое ООП на Kotlin

## Описание

Лабораторная работа посвящена изучению продвинутых концепций объектно-ориентированного
программирования в Kotlin.

## Изученные концепции

В ходе лабораторной работы были изучены следующие продвинутые концепции ООП в Kotlin:

### 1. Геттеры и сеттеры
Кастомные геттеры и сеттеры для контроля доступа к свойствам объектов.

**Пример из класса `OutpostWorker`:**
```kotlin
var energy: Int = 100
    set(value) {
        field = value.coerceIn(0, maxEnergy)
    }
```
### 2. Инкапсуляция
Изучен принцип инкапсуляции - скрытие внутреннего состояния объекта и управление доступом к нему.

Реализация через:

Модификаторы доступа (private, protected, internal, public)

Приватные сеттеры (private set)

Кастомные геттеры и сеттеры

Пример:
```kotlin
var level: Int = 1
    private set  // Запрет изменения уровня извне класса
```
### 3. Data-классы
Изучены data-классы - специальный тип классов в Kotlin для хранения данных с автоматической генерацией стандартных методов.
Пример OutpostResource:
```kotlin
data class OutpostResource(
    val id: Int,
    val name: String,
    var amount: Int
) {
    override fun toString(): String {
        return "Ресурс: $name (ID: $id) - Количество: $amount"
    }
}
```
### 4. Абстрактные классы
Изучены абстрактные классы - базовые классы, от которых нельзя создать объект напрямую.

Пример OutpostModule:
```kotlin
abstract class OutpostModule(
    val name: String,
    var level: Int = 1
) {
    fun upgrade() {
        level++
        println("Модуль $name повышен до уровня $level")
    }
    
    abstract fun performAction(manager: ResourceManager)
}
```
### 5. Интерфейсы
Изучены интерфейсы - контракты поведения, которые классы обязуются реализовать.
Пример интерфейса ModuleAction:
```kotlin
interface ModuleAction {
    fun execute(manager: ResourceManager)
}
```
Пример реализации интерфейсов
```kotlin
// Интерфейс
interface Movable {
    fun move()
    fun stop() {
        println("Остановка...")
    }
}

// Реализация в классе
class Car : Movable {
    override fun move() {
        println("Машина едет")
    }
}

// Полиморфизм
fun travel(vehicle: Movable) {
    vehicle.move()
    vehicle.stop()
}

// Использование
val car: Movable = Car()
travel(car)
```
### Проект "Galaxy Outpost Manager"
Описание проекта
Ты — управляющий космической базы. У тебя есть:

Рабочие (Workers)

Ресурсы (Resource)

Здания (OutpostModule)

Проект постепенно усиливается:

свойства с геттерами/сеттерами

data-классы для ресурсов

абстрактные классы для модулей

интерфейсы для действий

Структура проекта
```kotlin
src/
├── Main.kt                          # Главная точка входа программы
├── actions/                         # Интерфейсы
│   └── ModuleAction.kt
├── characters/                      # Персонажи
│   ├── Hero.kt
│   └── OutpostWorker.kt
├── example/                         # Примеры кода
│   ├── Interface.kt
│   └── Test.kt
├── modules/                         # Модули базы
│   ├── OutpostModule.kt
│   ├── EnergyGenerator.kt
│   └── ResearchLab.kt
└── resources/                       # Ресурсы
    ├── OutpostResource.kt
    └── ResourceManager.kt
```
## Дополнение: Лабораторная работа №11 — Sealed-классы и Object

### Galaxy Outpost Manager
Учебный проект на Kotlin, демонстрирующий основы объектно-ориентированного программирования и архитектурные приёмы языка.

### Sealed-классы
Sealed-классы используются для представления ограниченного набора состояний или результатов, которые известны на этапе компиляции.  
Они позволяют:
- гарантировать обработку всех возможных вариантов;
- безопасно использовать конструкцию `when` без `else`;
- удобно описывать состояния, события и результаты действий.

**Пример: результат работы модуля**
```kotlin
sealed class ModuleResult {
    data class Success(val message: String) : ModuleResult()
    data class ResourceProduced(val resourceName: String, val amount: Int) : ModuleResult()
    data class NotEnoughResources(
        val resourceName: String,
        val required: Int,
        val available: Int
    ) : ModuleResult()
    data class Error(val reason: String) : ModuleResult()
}

# Как запустить проект
Клонируйте репозиторий:
``` 
Object в Kotlin
object — это специальная конструкция Kotlin, которая создаёт единственный экземпляр класса (Singleton).

Особенности:

создаётся при первом обращении;
существует в одном экземпляре;
не имеет конструктора.
Пример: глобальный логгер
``` kotlin
object Logger {
    private var counter = 0
    fun log(message: String) {
        counter++
        println("[$counter] $message")
    }
}
```
Использование:
``` kotlin
Logger.log("Инициализация системы")
Logger.log("Модуль запущен")
```
object удобно использовать для:

логгеров;
конфигураций;
состояний без данных в sealed-классах;
утилитарных классов.

```bash
git clone <URL_репозитория>
```
###  Откройте проект в IntelliJ IDEA.
###  Запустите любой пример через контекстное меню или напрямую из `main`.
## Автор
[Щербаков Данил Николаевич]
## Лицензия
Проект создан в учебных целях.

# Лабораторная работа №12. Делегирование, lazy, observer-паттерн и сохранение состояния

## Изученные темы и примеры применения в Kotlin

### Делегирование свойств
Делегирование свойств позволяет передать логику хранения и обработки значения другому объекту.  
В Kotlin это реализуется с помощью ключевого слова `by`.

**Преимущества:**
- Уменьшение дублирования кода
- Централизованная логика проверки и обработки данных
- Более чистый и читаемый код

**Пример: ограничение диапазона значения энергии**
```kotlin
var energy: Int by Delegates.observable(100) { _, old, new ->
    println("Энергия изменилась: $old → $new")
}
```
### Lazy (ленивая инициализация)
lazy позволяет инициализировать объект только при первом обращении к нему.
Это полезно, если:

- Объект создаётся не всегда
- Его создание ресурсоёмкое
- Нужно отложить инициализацию

Пример:
```kotlin
val resourceManager by lazy {
ResourceManager()
}
```
Объект ResourceManager будет создан только при первом использовании.

### Observer-паттерн (наблюдатель)
Observer-паттерн позволяет объектам реагировать на изменения состояния другого объекта.

В проекте Galaxy Outpost Manager наблюдатели могут:

- Реагировать на изменение ресурсов
- Логировать события
- Уведомлять пользователя

Пример идеи:

- ResourceManager изменяет ресурсы
- Наблюдатель выводит сообщение в консоль при изменении

### Сохранение состояния
Для сохранения состояния проекта используется сериализация в JSON.

Это позволяет:

- Сохранять данные между запусками программы

- Хранить состояние в человекочитаемом формате

- Легко перенести логику в Android-приложение